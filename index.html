<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTU Computer Networks - Study Guide</title>
    <style>
        :root {
            --bg-color: #f4f7f6;
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --card-bg: #ffffff;
            --text-color: #333333;
            --border-color: #ddd;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #777;
            margin-bottom: 30px;
        }

        .question-block {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            overflow: hidden; /* To contain child elements */
        }

        .question-block h2 {
            background-color: var(--primary-color);
            color: white;
            margin: 0;
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1em;
        }

        .question-block h2:hover {
            background-color: #34495e;
        }

        .question-block h2 .toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s ease;
        }

        .question-block.active h2 .toggle-icon {
            transform: rotate(90deg);
        }

        .answer {
            padding: 20px;
            display: none; /* Hidden by default */
        }
        
        .question-block.active .answer {
            display: block; /* Shown when active */
        }

        .answer h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
            color: var(--primary-color);
        }

        .answer ul, .answer ol {
            padding-left: 20px;
        }

        .answer li {
            margin-bottom: 10px;
        }

        .answer strong {
            color: var(--primary-color);
        }

        .answer code {
            background-color: #eef;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: "Courier New", Courier, monospace;
        }

        /* Table Styling */
        .answer table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .answer th, .answer td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
        }

        .answer th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        .answer tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* Back to Top Button */
        #backToTop {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--secondary-color);
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none; /* Hidden by default */
            font-size: 16px;
            z-index: 1000;
        }

        #backToTop:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>GTU Computer Networks</h1>
        <p class="subtitle">Click on a question to reveal the answer.</p>

        <!-- LIST 1 -->
        <div class="question-block">
            <h2>1. Flow Control vs Error Control <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Flow Control</strong> is a mechanism to prevent the sender from overwhelming the receiver with data. It manages the rate of data transmission.</p>
                <p><strong>Error Control</strong> is a mechanism to detect and correct any errors in the transmitted data frames, ensuring that the receiver receives the correct data.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Basis of Comparison</th>
                            <th>Flow Control</th>
                            <th>Error Control</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Primary Objective</strong></td><td>To regulate the flow of data so that a fast sender does not flood a slow receiver.</td><td>To ensure that the data transmitted from the source to the destination is accurate and reliable.</td></tr>
                        <tr><td><strong>Problem Addressed</strong></td><td>Prevents <strong>buffer overflow</strong> at the receiver's end.</td><td>Detects and corrects <strong>corrupted frames</strong> (damaged bits) and <strong>lost frames</strong>.</td></tr>
                        <tr><td><strong>Main Function</strong></td><td>It is a <strong>speed-matching</strong> technique.</td><td>It is an <strong>accuracy and reliability</strong> technique.</td></tr>
                        <tr><td><strong>Mechanism Used</strong></td><td>Uses techniques like <strong>Stop-and-Wait Protocol</strong> and <strong>Sliding Window Protocol</strong>.</td><td>Uses <strong>Automatic Repeat Request (ARQ)</strong>. It employs error-detecting codes like <strong>Checksum</strong> and <strong>CRC</strong>.</td></tr>
                        <tr><td><strong>Use of Feedback</strong></td><td>The receiver sends an <strong>ACK</strong> for frames received.</td><td>The receiver sends an <strong>ACK</strong> for a correct frame and a <strong>NAK</strong> for a damaged frame, requesting retransmission.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>2. DNS – Definition, Purpose, Resolution, Hierarchy <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Definition:</h3>
                <p>The <strong>Domain Name System (DNS)</strong> is a hierarchical and decentralized naming system for computers, services, or other resources connected to the Internet. It translates human-readable domain names (e.g., <code>www.google.com</code>) into machine-readable IP addresses (e.g., <code>142.250.191.78</code>).</p>
                <h3>Purpose:</h3>
                <p>The primary purpose of DNS is to provide a more user-friendly way of accessing resources on the internet. It is difficult for humans to remember IP addresses, but easy to remember domain names. DNS acts as the internet's phonebook.</p>
                <h3>DNS Resolution (The Process):</h3>
                <ol>
                    <li><strong>Check Local Cache:</strong> The computer first checks its own local cache.</li>
                    <li><strong>Query Recursive DNS Server:</strong> The query is sent to a recursive DNS server (usually from the ISP).</li>
                    <li><strong>Query Root Server:</strong> The recursive server queries a <strong>Root Server</strong>, which directs it to the appropriate <strong>Top-Level Domain (TLD) Server</strong> (e.g., the <code>.com</code> server).</li>
                    <li><strong>Query TLD Server:</strong> The recursive server queries the TLD server, which directs it to the domain's <strong>Authoritative Name Server</strong> (e.g., <code>google.com</code>'s name server).</li>
                    <li><strong>Query Authoritative Name Server:</strong> The recursive server queries the authoritative name server, which knows the IP address.</li>
                    <li><strong>Return Response:</strong> The IP address is returned to the user's computer, and the browser can now connect.</li>
                </ol>
                <h3>DNS Hierarchy:</h3>
                <p>DNS is organized in a tree-like hierarchy: <strong>Root Level (.)</strong> → <strong>Top-Level Domain (TLD)</strong> (e.g., <code>.com</code>, <code>.in</code>) → <strong>Authoritative Domain Level</strong> (e.g., <code>google.com</code>) → <strong>Subdomain Level</strong> (e.g., <code>mail.google.com</code>).</p>
            </div>
        </div>

        <div class="question-block">
            <h2>3. HTTP – Persistent vs Non-Persistent <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Non-Persistent HTTP:</h3>
                <p>The client establishes a <strong>new TCP connection for every single object</strong> requested. The process is: connect → request one object → receive object → close connection. This is highly inefficient due to the overhead of setting up and tearing down multiple TCP connections.</p>
                <h3>Persistent HTTP (HTTP/1.1):</h3>
                <p>The client can send <strong>multiple requests over a single TCP connection</strong>. The connection is not closed after the first response but is kept open for subsequent requests. This is much more efficient as it avoids the overhead of setting up multiple connections, reducing latency.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>4. TCP vs UDP <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th>TCP (Transmission Control Protocol)</th><th>UDP (User Datagram Protocol)</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Connection</strong></td><td><strong>Connection-oriented</strong>. Establishes a connection via a three-way handshake.</td><td><strong>Connectionless</strong>. No connection is established before sending data.</td></tr>
                        <tr><td><strong>Reliability</strong></td><td><strong>Reliable</strong>. Guarantees delivery of data, error-free, and in the correct order.</td><td><strong>Unreliable</strong>. Does not guarantee delivery, order, or duplicate protection.</td></tr>
                        <tr><td><strong>Flow Control</strong></td><td>Uses a sliding window protocol to manage data flow.</td><td>No flow control.</td></tr>
                        <tr><td><strong>Congestion Control</strong></td><td>Uses mechanisms like Slow Start, Congestion Avoidance.</td><td>No congestion control.</td></tr>
                        <tr><td><strong>Speed</strong></td><td>Slower due to overhead of handshakes, acknowledgments, etc.</td><td>Faster due to low overhead.</td></tr>
                        <tr><td><strong>Header Size</strong></td><td>Large (20-60 bytes).</td><td>Small (8 bytes).</td></tr>
                        <tr><td><strong>Use Cases</strong></td><td>Web (HTTP), Email (SMTP), File Transfer (FTP).</td><td>Video/Audio streaming, Online gaming, DNS, VoIP.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>5. Distance Vector Routing + Count-to-Infinity <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Distance Vector Routing:</h3>
                <ul>
                    <li>Each router maintains a routing table (a vector) containing the distance (cost) and direction (next-hop router) to every other router.</li>
                    <li>Routers periodically share their entire routing table only with their <strong>immediate neighbors</strong>.</li>
                    <li>A router updates its table based on the information received from its neighbors using the Bellman-Ford algorithm.</li>
                </ul>
                <h3>Count-to-Infinity Problem:</h3>
                <p>This is a major drawback where "good news travels fast, but bad news travels slow."</p>
                <ul>
                    <li><strong>Scenario:</strong> Routers A, B, and C in a line. A is connected to B, and B is connected to C. The cost of each link is 1. Initially, A knows it can reach C via B with a cost of 2.</li>
                    <li><strong>Failure:</strong> If the link between B and C fails, B updates its table, setting the distance to C as infinity.</li>
                    <li><strong>The Problem:</strong> Before B can tell A about the failure, A might send its old routing table to B, saying it can reach C with a cost of 2. B, thinking it can reach C via A, updates its table to reach C with a cost of 3 (2+1).</li>
                    <li>This process repeats, with A and B incrementally increasing their routes to C until the value reaches infinity. This slow propagation of bad news is the "count-to-infinity" problem.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>6. Link State Routing + Steps <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Link State Routing:</h3>
                <ul>
                    <li>Each router discovers its immediate neighbors and the cost of the links to them.</li>
                    <li>This information is then <strong>flooded to all other routers</strong> in the network.</li>
                    <li>Every router builds a complete map of the entire network topology.</li>
                    <li>Using this map, each router independently calculates the shortest path to every other router using Dijkstra's algorithm.</li>
                </ul>
                <h3>Steps of Link State Routing:</h3>
                <ol>
                    <li><strong>Discover Neighbors:</strong> A router learns about its directly connected neighbors.</li>
                    <li><strong>Measure Link Cost:</strong> The router measures the cost or delay to each neighbor.</li>
                    <li><strong>Create Link State Packets (LSPs):</strong> The router creates an LSP containing its ID, a sequence number, and a list of all its neighbors and the associated link costs.</li>
                    <li><strong>Flood LSPs:</strong> The router floods this LSP to all other routers in the network.</li>
                    <li><strong>Build Topology Database:</strong> Each router stores all received LSPs to build a complete database of the network's topology.</li>
                    <li><strong>Compute Shortest Paths:</strong> Using Dijkstra's shortest path algorithm on this database, each router computes the shortest path to every destination and builds its routing table.</li>
                </ol>
            </div>
        </div>

        <div class="question-block">
            <h2>7. Stop-and-Wait / Go-Back-N / Selective Repeat <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Feature</th><th>Stop-and-Wait ARQ</th><th>Go-Back-N ARQ</th><th>Selective Repeat ARQ</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Sender Window Size</strong></td><td>1</td><td>&gt; 1 (e.g., N)</td><td>&gt; 1 (e.g., N)</td></tr>
                        <tr><td><strong>Receiver Window Size</strong></td><td>1</td><td>1</td><td>&gt; 1 (e.g., N)</td></tr>
                        <tr><td><strong>Efficiency</strong></td><td>Very low</td><td>Medium</td><td>High</td></tr>
                        <tr><td><strong>Mechanism</strong></td><td>Sender sends one frame and waits for its ACK before sending the next.</td><td>If a frame is lost, the sender retransmits the lost frame and <strong>all subsequent frames</strong>.</td><td>If a frame is lost, the sender <strong>only retransmits the specific lost frame</strong>.</td></tr>
                        <tr><td><strong>Receiver Behavior</strong></td><td>Only accepts frames in order.</td><td>Only accepts frames in order. Discards out-of-order frames.</td><td>Can accept out-of-order frames and buffers them until the missing frame arrives.</td></tr>
                        <tr><td><strong>Complexity</strong></td><td>Simple</td><td>Moderate</td><td>Complex</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>8. Subnetting + Subnet Masks + Number of Hosts <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Subnetting:</h3>
                <p>The process of dividing a single large network into multiple smaller, more efficient sub-networks (subnets). It is done by "borrowing" bits from the host portion of an IP address to use as the subnet portion.</p>
                <h3>Subnet Mask:</h3>
                <p>A 32-bit number that distinguishes the network and subnet portions from the host portion of an IP address. It has <code>1</code>s for all network and subnet bits and <code>0</code>s for all host bits.</p>
                <h3>Calculating Subnets and Hosts:</h3>
                <ul>
                    <li>Let <code>n</code> be the total number of host bits in the default class.</li>
                    <li>Let <code>s</code> be the number of bits borrowed for subnetting.</li>
                    <li>Let <code>h</code> be the number of remaining host bits (<code>h = n - s</code>).</li>
                    <li><strong>Number of Subnets:</strong> <code>2^s</code></li>
                    <li><strong>Number of Usable Hosts per Subnet:</strong> <code>2^h - 2</code> (Subtracting 2 for the network and broadcast addresses).</li>
                </ul>
                <p><strong>Example (Class C):</strong> If we borrow 3 bits (<code>s=3</code>), the new subnet mask is <code>255.255.255.224</code>. Number of subnets = <code>2^3 = 8</code>. Remaining host bits (<code>h</code>) = 5. Number of usable hosts per subnet = <code>2^5 - 2 = 30</code>.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>9. OSI Model – Layers and Functions <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Layer</th><th>Name</th><th>Primary Function</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Layer 7</strong></td><td><strong>Application</strong></td><td>Provides network services directly to user applications (HTTP, FTP, DNS).</td></tr>
                        <tr><td><strong>Layer 6</strong></td><td><strong>Presentation</strong></td><td>Data representation, translation, encryption, and compression.</td></tr>
                        <tr><td><strong>Layer 5</strong></td><td><strong>Session</strong></td><td>Establishes, manages, and terminates sessions between applications.</td></tr>
                        <tr><td><strong>Layer 4</strong></td><td><strong>Transport</strong></td><td>Provides end-to-end reliable (TCP) or unreliable (UDP) data delivery, segmentation, and flow control.</td></tr>
                        <tr><td><strong>Layer 3</strong></td><td><strong>Network</strong></td><td>Logical addressing (IP) and routing of packets across multiple networks.</td></tr>
                        <tr><td><strong>Layer 2</strong></td><td><strong>Data Link</strong></td><td>Framing, physical addressing (MAC), and error detection/correction for a single hop.</td></tr>
                        <tr><td><strong>Layer 1</strong></td><td><strong>Physical</strong></td><td>Transmission of raw bits (0s and 1s) over a physical medium (cables, signals).</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>10. Difference: Connection-oriented vs Connectionless <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th>Connection-Oriented Service</th><th>Connectionless Service</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Connection Setup</strong></td><td>Requires a prior connection setup (handshake) before data transfer.</td><td>No connection setup is required.</td></tr>
                        <tr><td><strong>Reliability</strong></td><td>Guarantees reliable and in-order delivery of data.</td><td>Does not guarantee delivery, order, or reliability.</td></tr>
                        <tr><td><strong>State</strong></td><td>Maintains state information about the connection.</td><td>Stateless; each packet is independent.</td></tr>
                        <tr><td><strong>Overhead</strong></td><td>Higher overhead due to handshakes and acknowledgments.</td><td>Low overhead.</td></tr>
                        <tr><td><strong>Example</strong></td><td><strong>TCP</strong>, Telephone Call.</td><td><strong>UDP</strong>, Sending a postcard.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>11. Piggybacking <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Piggybacking is a technique used in bi-directional communication where the acknowledgment for a received frame is carried back to the sender in the header of an outgoing data frame, instead of sending a separate, dedicated acknowledgment frame.</p>
                <p><strong>Purpose:</strong> The primary goal is to improve the efficiency of the network. By attaching the ACK to a data frame that is already being sent, the system saves bandwidth and reduces the total number of frames transmitted on the network.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>12. CRC Computation <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Cyclic Redundancy Check (CRC) is a powerful error-detecting code used to detect accidental changes to raw data.</p>
                <p><strong>Process at Sender:</strong></p>
                <ol>
                    <li>A generator polynomial, <code>G(x)</code>, is agreed upon by both sender and receiver.</li>
                    <li><code>k</code> zero bits are appended to the end of the data, where <code>k</code> is the degree of the generator polynomial.</li>
                    <li>The new augmented data is divided by <code>G(x)</code> using modulo-2 binary division.</li>
                    <li>The remainder (the CRC checksum) is appended to the original data, replacing the appended zeros.</li>
                    <li>This final codeword (data + CRC) is transmitted.</li>
                </ol>
                <p><strong>Process at Receiver:</strong></p>
                <ol>
                    <li>The receiver divides the received codeword by the same generator polynomial <code>G(x)</code>.</li>
                    <li>If the remainder of the division is <strong>zero</strong>, the receiver assumes the data is error-free.</li>
                    <li>If the remainder is <strong>non-zero</strong>, the receiver concludes that an error has occurred.</li>
                </ol>
            </div>
        </div>

        <div class="question-block">
            <h2>13. Packet Switching vs Circuit Switching <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th>Circuit Switching</th><th>Packet Switching</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Path</strong></td><td>A dedicated physical path is established for the entire session.</td><td>No dedicated path. Data is broken into packets that may travel different paths.</td></tr>
                        <tr><td><strong>Resource Allocation</strong></td><td>Resources (bandwidth) are reserved for the duration of the call.</td><td>Resources are allocated on demand and are shared among many users.</td></tr>
                        <tr><td><strong>Efficiency</strong></td><td>Inefficient for bursty data traffic as the dedicated path sits idle during silent periods.</td><td>Highly efficient as network resources are used only when needed.</td></tr>
                        <tr><td><strong>Reliability</strong></td><td>Less robust; if a switch in the path fails, the connection is terminated.</td><td>More robust; if a node fails, packets can be rerouted around it.</td></tr>
                        <tr><td><strong>Example</strong></td><td>Traditional Telephone Network (PSTN).</td><td>The Internet.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>14. Routing: Unicast vs Multicast vs Broadcast <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>Unicast:</strong> <strong>One-to-one.</strong> A single source sends a packet to a single, specific destination host. <em>Example:</em> A user downloading a file from a web server.</li>
                    <li><strong>Multicast:</strong> <strong>One-to-many.</strong> A single source sends a packet to a specific group of destination hosts that have "subscribed" to receive the traffic. <em>Example:</em> Streaming a live video conference to a group of participants.</li>
                    <li><strong>Broadcast:</strong> <strong>One-to-all.</strong> A single source sends a packet that is addressed to all hosts on the local network. <em>Example:</em> An ARP (Address Resolution Protocol) request.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>15. UDP Explanation <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> The User Datagram Protocol (UDP) is a transport layer protocol that provides a simple, connectionless, and unreliable message service.</p>
                <p><strong>Key Characteristics:</strong></p>
                <ul>
                    <li><strong>Connectionless:</strong> There is no handshaking between the sender and receiver before sending data.</li>
                    <li><strong>Unreliable:</strong> UDP does not guarantee that a datagram will reach its destination, nor does it guarantee the order of delivery.</li>
                    <li><strong>Low Overhead:</strong> The UDP header is very small (8 bytes), making it faster than TCP.</li>
                    <li><strong>Stateless:</strong> UDP does not track the state of a connection.</li>
                </ul>
                <p><strong>Applications:</strong> UDP is suitable for applications that prioritize speed over reliability, such as video streaming, voice over IP (VoIP), online gaming, and DNS queries.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>16. Transport Layer Duties <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>1. Segmentation and Reassembly:</h3>
                <ul>
                    <li><strong>Segmentation:</strong> The transport layer at the sender side takes large messages from the application layer and breaks them down into smaller data units called <strong>segments</strong>.</li>
                    <li><strong>Reassembly:</strong> The transport layer at the receiver side collects these segments and reassembles them in the correct order to reconstruct the original message.</li>
                </ul>
                <h3>2. Multiplexing and Demultiplexing:</h3>
                <ul>
                    <li><strong>Multiplexing (at Sender):</strong> The transport layer gathers data from multiple application processes and encapsulates this data into segments with a header containing <strong>port numbers</strong> to identify the source and destination application.</li>
                    <li><strong>Demultiplexing (at Receiver):</strong> When a segment arrives, the transport layer examines the destination port number and delivers the segment's data to the correct application process.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>17. Socket System Calls <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Socket System Calls</strong> are a set of functions used to create and manage network connections for communication between processes.</p>
                <h3>Server-Side Sequence:</h3>
                <ol>
                    <li><code>socket()</code>: Creates a new communication endpoint.</li>
                    <li><code>bind()</code>: Associates the socket with a specific IP address and port number.</li>
                    <li><code>listen()</code>: Puts the socket into a passive mode, ready to accept incoming connections.</li>
                    <li><code>accept()</code>: Blocks until a client requests a connection, then returns a new socket for that specific client.</li>
                    <li><code>recv()</code> / <code>send()</code>: Use the new socket to receive data from and send data to the client.</li>
                    <li><code>close()</code>: Closes the connection.</li>
                </ol>
                <h3>Client-Side Sequence:</h3>
                <ol>
                    <li><code>socket()</code>: Creates a new communication endpoint.</li>
                    <li><code>connect()</code>: Actively initiates a connection to a server's IP address and port number.</li>
                    <li><code>send()</code> / <code>recv()</code>: Use the socket to send data to and receive data from the server.</li>
                    <li><code>close()</code>: Closes the connection.</li>
                </ol>
            </div>
        </div>

        <div class="question-block">
            <h2>18. Congestion Control vs Flow Control vs Error Control <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th><strong>Flow Control</strong></th><th><strong>Congestion Control</strong></th><th><strong>Error Control</strong></th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Scope</strong></td><td><strong>Point-to-Point.</strong> Between a sender and a receiver.</td><td><strong>Network-wide.</strong> Involves all routers and hosts in the path.</td><td><strong>Point-to-Point.</strong> Between a sender and a receiver.</td></tr>
                        <tr><td><strong>Problem Addressed</strong></td><td>Prevents a fast sender from overwhelming a <strong>slow receiver</strong>.</td><td>Prevents the <strong>network itself</strong> from being overloaded by too much traffic.</td><td>Detects and corrects <strong>corrupted or lost</strong> data frames.</td></tr>
                        <tr><td><strong>What it Manages</strong></td><td>The receiver's buffer capacity.</td><td>The overall traffic load in the network.</td><td>The integrity of the data stream.</td></tr>
                        <tr><td><strong>Mechanism</strong></td><td>Sliding Window Protocol.</td><td>TCP's Slow Start, Congestion Avoidance, Fast Retransmit.</td><td>ARQ, Checksums, ACKs, NAKs.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- LIST 2 -->
        <div class="question-block">
            <h2>19. SMTP Protocol <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> The <strong>Simple Mail Transfer Protocol (SMTP)</strong> is a standard communication protocol for electronic mail transmission. It is a text-based protocol used for sending email from a client to a mail server or between mail servers.</p>
                <p><strong>Key Characteristics:</strong></p>
                <ul>
                    <li><strong>Push Protocol:</strong> SMTP is designed for "pushing" emails from a client to a server. It is not used for retrieving email.</li>
                    <li><strong>TCP-based:</strong> It operates over TCP port 25 for reliable communication.</li>
                    <li><strong>Simple Commands:</strong> It uses simple, human-readable commands like <code>HELO</code>, <code>MAIL FROM</code>, <code>RCPT TO</code>, and <code>DATA</code>.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>20. Explain HTTP format (request/response) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>HTTP Request Message Format:</h3>
                <ol>
                    <li><strong>Request Line:</strong> Contains the HTTP method (e.g., <code>GET</code>), the URL, and the HTTP version (e.g., <code>HTTP/1.1</code>).</li>
                    <li><strong>Header Lines:</strong> Contain additional information (e.g., <code>Host</code>, <code>User-Agent</code>).</li>
                    <li><strong>Entity Body:</strong> (Optional) Contains data being sent to the server, typically used with <code>POST</code> requests.</li>
                </ol>
                <h3>HTTP Response Message Format:</h3>
                <ol>
                    <li><strong>Status Line:</strong> Contains the HTTP version, a status code (e.g., <code>200 OK</code>), and a status phrase.</li>
                    <li><strong>Header Lines:</strong> Contain information about the response and the server (e.g., <code>Date</code>, <code>Content-Type</code>).</li>
                    <li><strong>Entity Body:</strong> Contains the actual resource requested by the client (e.g., the HTML document).</li>
                </ol>
            </div>
        </div>

        <div class="question-block">
            <h2>21. MAC sublayer issues / CSMA / ALOHA <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>MAC Sublayer Issue:</h3>
                <p>The primary issue for the Medium Access Control (MAC) sublayer is the <strong>multiple access problem</strong>. When multiple devices share a common transmission medium, they need a mechanism to coordinate access to prevent data collisions.</p>
                <h3>ALOHA:</h3>
                <ul>
                    <li><strong>Pure ALOHA:</strong> Stations transmit whenever they have data. If a collision occurs, they wait a random amount of time and retransmit.</li>
                    <li><strong>Slotted ALOHA:</strong> Time is divided into discrete slots. Stations can only transmit at the beginning of a time slot, which reduces the probability of collisions.</li>
                </ul>
                <h3>CSMA (Carrier Sense Multiple Access):</h3>
                <ul>
                    <li>An improvement over ALOHA where a station first <strong>listens to the channel (carrier sense)</strong> to see if it is idle before transmitting.</li>
                    <li><strong>1-Persistent CSMA:</strong> If the channel is busy, the station continuously listens and transmits immediately when it becomes idle.</li>
                    <li><strong>Non-Persistent CSMA:</strong> If the channel is busy, the station waits for a random period of time before sensing the channel again.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>22. Bit Stuffing <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Bit stuffing is a technique used for data transparency to prevent a specific bit pattern within the data from being misinterpreted as a control or framing sequence.</p>
                <p><strong>How it Works:</strong></p>
                <ul>
                    <li>A specific flag pattern, such as <code>01111110</code>, is used to mark the beginning and end of a frame.</li>
                    <li>To ensure this pattern does not appear in the data payload, the sender inserts an extra <code>0</code> after every sequence of five consecutive <code>1</code>s in the data.</li>
                    <li><strong>At the receiver:</strong> The receiver removes the stuffed <code>0</code> after every five <code>1</code>s to restore the original data.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>23. Error Detection methods (parity, CRC, Hamming) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>Parity Check:</strong> Adds a single redundant bit to a block of data to make the total number of 1s either even or odd. Can only detect an odd number of bit errors.</li>
                    <li><strong>CRC (Cyclic Redundancy Check):</strong> A powerful error-detection scheme. The sender treats the data as a large number and divides it by a predetermined polynomial. The remainder (the CRC checksum) is appended to the data. The receiver performs the same division; a non-zero remainder indicates an error.</li>
                    <li><strong>Hamming Code:</strong> An error-<strong>correcting</strong> code. It adds multiple redundant bits at specific positions within the data block, allowing the receiver to identify and correct single-bit errors.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>24. Datagram vs Virtual Circuit networks <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th>Datagram Network (Connectionless)</th><th>Virtual Circuit Network (Connection-Oriented)</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Connection Setup</strong></td><td>No connection setup is required.</td><td>A logical path (virtual circuit) is established before data transfer.</td></tr>
                        <tr><td><strong>Addressing</strong></td><td>Each packet contains the full source and destination address.</td><td>Each packet contains a small Virtual Circuit Identifier (VCI).</td></tr>
                        <tr><td><strong>Routing</strong></td><td>Packets can take different routes to the destination.</td><td>All packets follow the same pre-established path.</td></tr>
                        <tr><td><strong>Order of Packets</strong></td><td>Packets may arrive out of order.</td><td>Packets always arrive in the correct order.</td></tr>
                        <tr><td><strong>Example</strong></td><td>The Internet (uses IP).</td><td>ATM (Asynchronous Transfer Mode), Frame Relay.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>25. Distance Vector Routing (general) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p>Distance Vector Routing is a simple routing algorithm where each router maintains a routing table (a vector) that lists the distance (cost) and the direction (next-hop router) for every known destination.</p>
                <ul>
                    <li><strong>Information Sharing:</strong> Routers periodically share their entire routing table only with their <strong>directly connected neighbors</strong>.</li>
                    <li><strong>Update Mechanism:</strong> A router updates its own routing table based on the information received from its neighbors, choosing the path with the lowest total cost.</li>
                    <li><strong>Problem:</strong> This algorithm is slow to adapt to network changes (slow convergence) and is susceptible to routing loops and the <strong>count-to-infinity problem</strong>.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>26. IPv4 Classes / Address ranges <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Class</th><th>First Octet Range</th><th>Network ID</th><th>Default Subnet Mask</th><th>Use Case</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>A</strong></td><td><code>1</code> to <code>126</code></td><td>First Octet</td><td><code>255.0.0.0</code></td><td>Very large networks.</td></tr>
                        <tr><td><strong>B</strong></td><td><code>128</code> to <code>191</code></td><td>First Two Octets</td><td><code>255.255.0.0</code></td><td>Medium to large networks.</td></tr>
                        <tr><td><strong>C</strong></td><td><code>192</code> to <code>223</code></td><td>First Three Octets</td><td><code>255.255.255.0</code></td><td>Small networks.</td></tr>
                        <tr><td><strong>D</strong></td><td><code>224</code> to <code>239</code></td><td>N/A</td><td>N/A</td><td>Multicasting.</td></tr>
                        <tr><td><strong>E</strong></td><td><code>240</code> to <code>255</code></td><td>N/A</td><td>N/A</td><td>Experimental use.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>27. TCP Connection Establishment (Three-way handshake) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p>The three-way handshake is a process used to establish a reliable TCP connection between a client and a server. It synchronizes the initial sequence numbers (ISN) for both sides.</p>
                <ol>
                    <li><strong>SYN:</strong> The client sends a TCP segment with the <code>SYN</code> flag set and its chosen initial sequence number <code>SEQ = x</code>.</li>
                    <li><strong>SYN-ACK:</strong> The server responds with a segment that has both the <code>SYN</code> and <code>ACK</code> flags set. It includes its own initial sequence number <code>SEQ = y</code> and acknowledges the client's sequence number with <code>ACK = x + 1</code>.</li>
                    <li><strong>ACK:</strong> The client sends a final segment with the <code>ACK</code> flag set, acknowledging the server's sequence number with <code>ACK = y + 1</code>. The connection is now established.</li>
                </ol>
            </div>
        </div>

        <div class="question-block">
            <h2>28. Types of Network Topologies <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>Bus Topology:</strong> All devices are connected to a single central cable. <em>Pros:</em> Simple, inexpensive. <em>Cons:</em> A cable break disables the entire network.</li>
                    <li><strong>Star Topology:</strong> All devices are connected to a central hub or switch. <em>Pros:</em> Easy to manage, a single cable failure affects only one device. <em>Cons:</em> The central device is a single point of failure.</li>
                    <li><strong>Ring Topology:</strong> Devices are connected in a circular fashion, and data passes from one device to the next. <em>Pros:</em> Orderly data transmission. <em>Cons:</em> A break in the ring can bring down the network.</li>
                    <li><strong>Mesh Topology:</strong> Every device is interconnected with every other device. <em>Pros:</em> Highly reliable. <em>Cons:</em> Expensive and complex.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>29. Types of delays in networks <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>Processing Delay:</strong> Time required for a router to examine a packet's header and determine the outgoing interface.</li>
                    <li><strong>Queuing Delay:</strong> Time a packet spends waiting in a queue at a router's output port before it can be transmitted.</li>
                    <li><strong>Transmission Delay:</strong> Time required to push all the bits of a packet onto the link. <code>(Packet Size) / (Bandwidth)</code>.</li>
                    <li><strong>Propagation Delay:</strong> Time it takes for a bit to travel from the sender to the receiver over the physical medium. <code>(Distance) / (Propagation Speed)</code>.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>30. Network devices: router, bridge, gateway, repeater <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>Repeater (Layer 1):</strong> Regenerates and amplifies signals to extend the physical length of a network.</li>
                    <li><strong>Bridge (Layer 2):</strong> Connects two or more LAN segments and makes forwarding decisions based on MAC addresses.</li>
                    <li><strong>Router (Layer 3):</strong> Connects different networks and forwards packets between them based on their IP addresses.</li>
                    <li><strong>Gateway (Layer 4-7):</strong> Acts as a "gate" between two networks that use different protocols (e.g., TCP/IP and a mainframe network).</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>31. Subnet and benefits <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Subnetting:</h3>
                <p>The process of dividing a single, large IP network into multiple smaller, more manageable sub-networks (subnets).</p>
                <h3>Benefits of Subnetting:</h3>
                <ul>
                    <li><strong>Reduced Broadcast Traffic:</strong> Broadcasts are confined to a single subnet, improving performance.</li>
                    <li><strong>Enhanced Security:</strong> Subnets can be used to create security boundaries.</li>
                    <li><strong>Improved Network Management:</strong> Smaller, isolated subnets are easier to troubleshoot and manage.</li>
                    <li><strong>Efficient IP Address Utilization:</strong> Allows for more efficient allocation of IP addresses.</li>
                </ul>
            </div>
        </div>

        <!-- LIST 3 -->
        <div class="question-block">
            <h2>32. IMAP / Email protocols <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Email Protocols</strong> are used for sending and retrieving electronic mail.</p>
                <ul>
                    <li><strong>SMTP (Simple Mail Transfer Protocol):</strong> Used to <strong>send</strong> email from a client to a server and between mail servers.</li>
                    <li><strong>POP3 (Post Office Protocol 3):</strong> A simple protocol for <strong>retrieving</strong> email. It typically downloads emails to the client device and deletes them from the server.</li>
                    <li><strong>IMAP (Internet Message Access Protocol):</strong> A more advanced protocol for <strong>retrieving</strong> email. Emails are kept on the server, enabling synchronization across multiple devices.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>33. Throughput / Delay / Loss definitions <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>Throughput:</strong> The rate at which data is successfully transmitted from a sender to a receiver over a communication channel. It represents the actual, usable bandwidth.</li>
                    <li><strong>Delay (or Latency):</strong> The total time it takes for a packet to travel from the source to the destination. It is the sum of processing, queuing, transmission, and propagation delays.</li>
                    <li><strong>Loss:</strong> The phenomenon where packets are discarded and never reach their destination, often caused by network congestion.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>34. Computer network definition and types (LAN/MAN/WAN) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Definition:</h3>
                <p>A computer network is a collection of interconnected computing devices that are able to communicate and share resources with each other.</p>
                <h3>Types of Networks:</h3>
                <ul>
                    <li><strong>LAN (Local Area Network):</strong> Spans a small geographical area, such as a single office or building.</li>
                    <li><strong>MAN (Metropolitan Area Network):</strong> Spans a larger area, such as a city or a large university campus.</li>
                    <li><strong>WAN (Wide Area Network):</strong> Spans a very large geographical area, like a country or the entire globe. The Internet is the largest WAN.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>35. Physical vs Logical Address <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th><strong>Physical Address (MAC Address)</strong></th><th><strong>Logical Address (IP Address)</strong></th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Layer</strong></td><td>Data Link Layer (Layer 2)</td><td>Network Layer (Layer 3)</td></tr>
                        <tr><td><strong>Purpose</strong></td><td>Addressing for communication within a <strong>local network</strong>.</td><td>Addressing for routing across <strong>different networks</strong>.</td></tr>
                        <tr><td><strong>Assignment</strong></td><td>Hard-coded and permanently assigned by the device manufacturer.</td><td>Assigned by a network administrator or an ISP, and can be changed.</td></tr>
                        <tr><td><strong>Hierarchy</strong></td><td>Flat address space.</td><td>Hierarchical address space (Network ID + Host ID).</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>36. Store-and-Forward Packet Switching <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Store-and-forward is a switching technique where a router receives an <strong>entire packet</strong>, stores it in its buffer, checks for errors, and only then forwards it to the next hop.</p>
                <p><strong>Key Implication:</strong> This technique introduces a delay at each hop equal to the time required to receive the entire packet. However, it ensures that corrupted packets are not forwarded, saving network bandwidth.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>37. Transport Layer Services <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p>The Transport Layer provides end-to-end communication services for applications. Its key services include:</p>
                <ul>
                    <li><strong>Process-to-Process Communication:</strong> Using port numbers to deliver data to the correct application process.</li>
                    <li><strong>Connection-Oriented/Connectionless Services:</strong> Providing either a reliable service (TCP) or an unreliable service (UDP).</li>
                    <li><strong>Reliable Data Transfer:</strong> Ensuring that data is delivered without errors and in the correct order.</li>
                    <li><strong>Flow Control:</strong> Preventing a fast sender from overwhelming a slow receiver.</li>
                    <li><strong>Congestion Control:</strong> Preventing a sender from overwhelming the network itself.</li>
                    <li><strong>Segmentation and Reassembly:</strong> Breaking large messages into smaller segments and reassembling them.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>38. WDM (Wavelength Division Multiplexing) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Wavelength Division Multiplexing (WDM) is a fiber-optic transmission technology that combines multiple optical signals of different wavelengths (colors) onto a single optical fiber.</p>
                <p><strong>Purpose:</strong> To dramatically increase the bandwidth capacity of a single fiber without laying new cables. Each wavelength acts as a separate channel.</p>
                <p><strong>Components:</strong> A <strong>Multiplexer (Mux)</strong> combines signals, and a <strong>Demultiplexer (Demux)</strong> splits them back at the receiving end.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>39. Broadcast vs Multicast routing note <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th><strong>Broadcast Routing</strong></th><th><strong>Multicast Routing</strong></th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Communication Type</strong></td><td>One-to-all. A packet is delivered to <strong>every host</strong> in the network.</td><td>One-to-a-group. A packet is delivered only to a <strong>specific group</strong> of hosts.</td></tr>
                        <tr><td><strong>Addressing</strong></td><td>Uses a special broadcast address (e.g., <code>255.255.255.255</code>).</td><td>Uses a special multicast address (e.g., <code>224.0.0.0</code> to <code>239.255.255.255</code>).</td></tr>
                        <tr><td><strong>Scalability</strong></td><td>Poor. Can consume significant network resources.</td><td>Much more scalable than broadcast.</td></tr>
                        <tr><td><strong>Example</strong></td><td>An ARP request.</td><td>Streaming a live video conference.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>40. Encapsulation at transport layer <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Encapsulation at the transport layer is the process of taking data from the application layer and wrapping it with a transport layer header to create a <strong>segment</strong> (for TCP) or a <strong>datagram</strong> (for UDP).</p>
                <p><strong>Purpose of the Transport Layer Header:</strong></p>
                <ul>
                    <li><strong>Port Numbers:</strong> To enable <strong>demultiplexing</strong>, ensuring the data is delivered to the correct application process.</li>
                    <li><strong>Sequence Numbers (TCP):</strong> Used to keep track of the order of segments.</li>
                    <li><strong>Acknowledgment Numbers (TCP):</strong> Used to provide reliability.</li>
                    <li><strong>Checksum:</strong> Used for error detection.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>41. Classful vs Classless addressing <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th><strong>Classful Addressing</strong></th><th><strong>Classless Addressing (CIDR)</strong></th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Structure</strong></td><td>The network and host portions are fixed in size and determined by the address class (A, B, or C).</td><td>The network and host portions are of variable length, defined by a <strong>subnet mask</strong> or <strong>prefix length</strong> (e.g., /24).</td></tr>
                        <tr><td><strong>Flexibility</strong></td><td>Inflexible. Leads to significant waste of IP addresses.</td><td>Highly flexible. Allows for efficient allocation of IP addresses.</td></tr>
                        <tr><td><strong>Routing</strong></td><td>Less efficient. Routing protocols do not carry subnet mask information.</td><td>More efficient. Routing protocols carry the prefix length, enabling <strong>supernetting</strong>.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>42. Shortest path routing (Dijkstra) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Dijkstra's algorithm is a shortest-path routing algorithm used in link-state routing protocols. Each router runs the algorithm to calculate the least-cost path from itself to every other destination in the network.</p>
                <p><strong>Algorithm Steps (Simplified):</strong></p>
                <ol>
                    <li><strong>Initialization:</strong> The source node is marked as permanent with a cost of 0. All other nodes are marked as temporary with a cost of infinity.</li>
                    <li><strong>Iteration:</strong> The algorithm repeatedly selects the temporary node with the lowest cost and marks it as permanent.</li>
                    <li><strong>Update:</strong> For the newly permanent node, it examines the cost to each of its adjacent temporary neighbors and updates them if a shorter path is found.</li>
                    <li><strong>Completion:</strong> The process repeats until all nodes have been marked as permanent.</li>
                </ol>
            </div>
        </div>

        <div class="question-block">
            <h2>43. IP header / IPv4 datagram fields <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p>An IPv4 datagram consists of a header followed by the data. The key fields in the 20-byte header are:</p>
                <ul>
                    <li><strong>Version (4 bits):</strong> Specifies the IP version (e.g., 4).</li>
                    <li><strong>Header Length (IHL) (4 bits):</strong> Length of the header in 32-bit words.</li>
                    <li><strong>Type of Service (ToS) (8 bits):</strong> Used for Quality of Service (QoS).</li>
                    <li><strong>Total Length (16 bits):</strong> Total length of the datagram (header + data) in bytes.</li>
                    <li><strong>Identification (16 bits):</strong> Used to uniquely identify fragments of an original IP datagram.</li>
                    <li><strong>Flags (3 bits):</strong> Used to control and identify fragments.</li>
                    <li><strong>Fragment Offset (13 bits):</strong> Specifies the position of a fragment in the original datagram.</li>
                    <li><strong>Time-to-Live (TTL) (8 bits):</strong> A counter that is decremented by each router to prevent packets from looping forever.</li>
                    <li><strong>Protocol (8 bits):</strong> Indicates which transport-layer protocol the data belongs to (e.g., TCP=6, UDP=17).</li>
                    <li><strong>Header Checksum (16 bits):</strong> An error-detecting code for the header.</li>
                    <li><strong>Source IP Address (32 bits)</strong></li>
                    <li><strong>Destination IP Address (32 bits)</strong></li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>44. Random access protocols (Slotted ALOHA etc.) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>ALOHA:</strong> Stations transmit whenever they have data. If a collision occurs, they wait a random time and retransmit.</li>
                    <li><strong>Slotted ALOHA:</strong> Time is divided into discrete slots. Stations can only transmit at the beginning of a slot, which reduces the probability of collisions.</li>
                    <li><strong>CSMA (Carrier Sense Multiple Access):</strong> Stations "listen before they speak." A station senses the channel. If it's idle, it transmits.</li>
                    <li><strong>CSMA/CD (Collision Detection):</strong> Used in wired Ethernet. A station transmits while continuing to listen. If it detects a collision, it immediately stops transmitting and retries.</li>
                    <li><strong>CSMA/CA (Collision Avoidance):</strong> Used in wireless Wi-Fi. It tries to avoid collisions before they happen using a "virtual carrier sense" (RTS/CTS handshake).</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>45. Congestion meaning, impact, metrics <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Meaning:</h3>
                <p>Congestion occurs when the load on the network exceeds its available capacity, leading to a decline in performance.</p>
                <h3>Impact of Congestion:</h3>
                <ul>
                    <li><strong>Increased Delay:</strong> Packets spend a long time waiting in router queues.</li>
                    <li><strong>Packet Loss:</strong> Router buffers become full and have to drop new incoming packets.</li>
                    <li><strong>Reduced Throughput:</strong> The effective rate of successful data delivery drops.</li>
                </ul>
                <h3>Metrics to Measure Congestion:</h3>
                <ul>
                    <li><strong>Delay:</strong> A significant increase in the average round-trip time (RTT).</li>
                    <li><strong>Packet Loss Rate:</strong> A high percentage of lost packets.</li>
                    <li><strong>Throughput:</strong> A decrease in the network's throughput.</li>
                </ul>
            </div>
        </div>

        <!-- LIST 4 -->
        <div class="question-block">
            <h2>46. What is a protocol vs standard <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Protocol:</strong> A set of rules and conventions that govern how data is transmitted and received between two or more devices on a network. <em>Example:</em> TCP, HTTP.</p>
                <p><strong>Standard:</strong> A formally established specification that has been approved by a recognized standards body. Standards ensure interoperability. A protocol often becomes a standard. <em>Example:</em> The specifications for HTTP/1.1 are defined in an IETF standard, RFC 2616.</p>
                <p><strong>Key Difference:</strong> A protocol is the *set of rules*, while a standard is the *official document* that defines those rules.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>47. Web architecture + URL structure <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <h3>Web Architecture:</h3>
                <p>The World Wide Web is based on a <strong>client-server architecture</strong>. The client is a web browser, and the server is a computer that hosts websites. Communication is governed by the <strong>HTTP</strong> protocol.</p>
                <h3>URL Structure:</h3>
                <p>A Uniform Resource Locator (URL) is the address of a specific resource on the web. It has several components: <code>protocol://host:port/path?query</code></p>
                <ul>
                    <li><strong>Protocol:</strong> e.g., <code>http</code>, <code>https</code>.</li>
                    <li><strong>Host:</strong> The domain name of the server (e.g., <code>www.google.com</code>).</li>
                    <li><strong>Port (Optional):</strong> Defaults to 80 for HTTP and 443 for HTTPS.</li>
                    <li><strong>Path:</strong> The location of the resource on the server.</li>
                    <li><strong>Query (Optional):</strong> A string of data passed to the server.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>48. HTTP methods <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>GET:</strong> Requests a representation of the specified resource. Should only retrieve data.</li>
                    <li><strong>POST:</strong> Submits data to be processed to the specified resource, often causing a change in state.</li>
                    <li><strong>PUT:</strong> Replaces all current representations of the target resource with the uploaded content.</li>
                    <li><strong>DELETE:</strong> Deletes the specified resource.</li>
                    <li><strong>HEAD:</strong> Similar to GET, but it requests only the headers of the response, without the response body.</li>
                    <li><strong>PATCH:</strong> Applies partial modifications to a resource.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>49. Two-dimensional parity <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> Two-dimensional parity is an error detection method that organizes data into a table and calculates a parity bit for each row and each column.</p>
                <p><strong>Advantage:</strong></p>
                <ul>
                    <li>It can detect all <strong>1-bit and 2-bit errors</strong>.</li>
                    <li>It can <strong>correct single-bit errors</strong>. The intersection of the row and column that has a parity error pinpoints the incorrect bit.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>50. Virtual circuit advantages <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <ul>
                    <li><strong>In-Order Delivery:</strong> Since all packets follow the same pre-established path, they are guaranteed to arrive in the correct order.</li>
                    <li><strong>Simplified Routing:</strong> Routers only need to look up a small <strong>Virtual Circuit Identifier (VCI)</strong>, which is faster than a full IP lookup.</li>
                    <li><strong>Resource Reservation and QoS:</strong> The path can be reserved in advance, allowing for guaranteed bandwidth and quality of service (QoS).</li>
                    <li><strong>Reliability:</strong> The network can provide reliability guarantees, as the connection is monitored and the network can allocate resources to prevent packet loss.</li>
                </ul>
            </div>
        </div>

        <div class="question-block">
            <h2>51. Difference between fixed-size and variable-size framing <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <table>
                    <thead>
                        <tr><th>Basis of Comparison</th><th><strong>Fixed-Size Framing</strong></th><th><strong>Variable-Size Framing</strong></th></tr>
                    </thead>
                    <tbody>
                        <tr><td><strong>Frame Length</strong></td><td>The size of each frame is predetermined and does not vary.</td><td>Frames can have different lengths depending on the amount of data being sent.</td></tr>
                        <tr><td><strong>Need for Framing</strong></td><td>Not necessary to define the start/end of a frame, as the boundaries are known.</td><td>Requires a mechanism to delineate the start and end of each frame.</td></tr>
                        <tr><td><strong>Delineation Method</strong></td><td>The receiver simply counts the number of bits/bytes to know where a frame ends.</td><td>Uses special bit patterns (flags) or character-based methods like byte stuffing.</td></tr>
                        <tr><td><strong>Complexity</strong></td><td>Simpler to implement at the receiver.</td><td>More complex due to the need for pattern matching and stuffing/unstuffing.</td></tr>
                        <tr><td><strong>Efficiency</strong></td><td>Can be inefficient if data is smaller than the fixed frame size, leading to wasted space (padding).</td><td>More efficient as the frame size can be tailored to the data being sent.</td></tr>
                        <tr><td><strong>Example</strong></td><td><strong>ATM (Asynchronous Transfer Mode)</strong> cells, which are always 53 bytes.</td><td><strong>Ethernet</strong> and <strong>PPP (Point-to-Point Protocol)</strong>.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>52. Optimality principle (routing) <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>Definition:</strong> The optimality principle is a fundamental concept in routing that states: <strong>if router J is on the optimal path from router I to router K, then the optimal path from J to K must also follow the same route.</strong></p>
                <p><strong>Implication:</strong> This principle implies that the set of optimal routes from all sources to a given destination form a tree rooted at the destination. This tree is called a <strong>sink tree</strong> or a <strong>shortest-path tree</strong>. The goal of all routing algorithms is to discover and use these sink trees for all destinations.</p>
            </div>
        </div>

        <div class="question-block">
            <h2>53. LRC example <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p><strong>LRC (Longitudinal Redundancy Check)</strong> is another name for two-dimensional parity. Here is an example using even parity.</p>
                <h3>Example:</h3>
                <p><strong>Data to be sent:</strong> <code>10110010</code> <code>00101101</code> <code>11101001</code></p>
                <p>The table below shows the data with calculated row and column parity bits.</p>
                <table>
                    <thead>
                        <tr><th colspan="9">Data Block</th><th>Row Parity</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td></td><td><strong>0</strong></td></tr>
                        <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td></td><td><strong>0</strong></td></tr>
                        <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td></td><td><strong>1</strong></td></tr>
                        <tr><td colspan="9"><strong>Column Parity</strong></td><td></td></tr>
                        <tr><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td></td><td></td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="question-block">
            <h2>54. Explain socket importance in transport layer <span class="toggle-icon">▶</span></h2>
            <div class="answer">
                <p>A <strong>socket</strong> is the endpoint for sending or receiving data across a network. It is identified by a combination of an IP address and a port number.</p>
                <h3>Importance in the Transport Layer:</h3>
                <ul>
                    <li><strong>Enabling Process-to-Process Communication:</strong> The primary role of a socket is to allow the transport layer to deliver data to the correct application process on a host. While the IP address delivers the data to the correct computer, the <strong>port number</strong> in the socket address delivers it to the correct application (e.g., web browser, email client).</li>
                    <li><strong>Multiplexing and Demultiplexing:</strong> Sockets are the foundation of multiplexing (at the sender) and demultiplexing (at the receiver). The transport layer uses port numbers to manage data streams from multiple applications concurrently over a single network connection.</li>
                    <li><strong>Interface for Applications:</strong> Sockets provide a standard <strong>Application Programming Interface (API)</strong> for applications. When an application wants to send or receive data, it uses socket system calls to interact with the transport layer, abstracting away the complexities of the underlying network.</li>
                    <li><strong>Abstracting the Network:</strong> From an application's perspective, it is simply reading from and writing to a socket, without needing to know about TCP handshakes, IP routing, or Ethernet frames. The socket handles all the details of the network connection.</li>
                </ul>
            </div>
        </div>

    </div>

    <button id="backToTop" title="Go to top">Top</button>

    <script>
        // Get all question blocks
        const questionBlocks = document.querySelectorAll('.question-block');
        const backToTopButton = document.getElementById('backToTop');

        // Add click event listener to each question block's h2
        questionBlocks.forEach(block => {
            const header = block.querySelector('h2');
            header.addEventListener('click', () => {
                // Toggle the 'active' class on the parent block
                block.classList.toggle('active');
            });
        });

        // Show/hide the back to top button based on scroll position
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 100) {
                backToTopButton.style.display = "block";
            } else {
                backToTopButton.style.display = "none";
            }
        });

        // Scroll to the top when the button is clicked
        backToTopButton.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    </script>
</body>
</html>
